/*
   Пример работы ПИД регулятора в автоматическом режиме по встроенному таймеру
   Давайте представим, что на 3 пине у нас спираль нагрева, подключенная через мосфет,
   управляем ШИМ сигналом
   И есть какой то абстрактный датчик температуры, на который влияет спираль
*/

// использовать целочисленные вычисления легче и быстрее, но менее точно)
// задефайнить PID_INTEGER ДО ПОДКЛЮЧЕНИЯ БИБЛИОТЕКИ
#define PID_INTEGER
#include "GyverPID.h"

// (коэффициент П, коэффициент И, коэффициент Д, период дискретизации dt (мс) )
GyverPID regulator(0.1, 0.05, 0.01, 10);

// или так:
// GyverPID regulator(0.1, 0.05, 0.01);	// можно П, И, Д, без dt, dt будет по умолч. 100 мс

void setup() {
  regulator.setDirection(NORMAL); // направление регулирования (NORMAL/REVERSE). ПО УМОЛЧАНИЮ СТОИТ NORMAL
  regulator.setLimits(0, 255);    // пределы (ставим для 8 битного ШИМ). ПО УМОЛЧАНИЮ СТОЯТ 0 И 255
  regulator.setpoint = 50;        // сообщаем регулятору температуру, которую он должен поддерживать
  regulator.tune(0.1, 0.1, 0.1);  // изменить коэффициенты можно в любое время
}

void loop() {
  int temp;                 // читаем с датчика температуру
  regulator.input = temp;   // сообщаем регулятору текущую температуру

  // getResultTimer возвращает значение для управляющего устройства
  // (после вызова можно получать это значение как regulator.output)
  // обновление происходит по встроенному таймеру на millis()
  analogWrite(3, regulator.getResultTimer());  // отправляем на мосфет

  // .getResultTimer() по сути возвращает regulator.output
}
