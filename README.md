# GyverLibs by AlexGyver
## Написанные с нуля/модифицированные библиотеки для Arduino
### GyverButton v2.6
Библиотека для многофункциональной отработки нажатия кнопок с Arduino. Возможности:
- Работа с нормально замкнутыми и нормально разомкнутыми кнопками
- Работа с подключением PULL_UP и PULL_DOWN
- Опрос кнопки с программным антидребезгом контактов
- Настраиваемое время антидребезга
- Отработка нажатия, удерживания, отпускания, клика по кнопке
- Настраиваемый таймаут удержания
- Отработка одиночного, двойного и тройного нажатия (вынесено отдельно)
- Отработка любого количества нажатий кнопки (функция возвращает количество нажатий)
- Настраиваемый таймаут повторного нажатия/удержания
- Функция изменения значения переменной с заданным шагом и заданным интервалом по времени
- Возможность опрашивать не кнопку, а напрямую давать величину (все возможности библиотеки для матричных и резистивных клавиатур)
#### Методы и функции библиотеки
<details>
<summary>РАЗВЕРНУТЬ</summary>
<p>
Смотри примеры в папке examples!

```C
GButton(uint8_t pin);								// класс кнопки, принимает пин
	
GButton(uint8_t PIN, boolean type, boolean dir);	// класс кнопки, принимает PIN пин, тип type (HIGH_PULL / LOW_PULL) и направление dir (NORM_OPEN / NORM_CLOSE)
													// HIGH_PULL - кнопка подключена к GND, пин подтянут к VCC, pinMode - INPUT_PULLUP (по умолчанию)
													// LOW_PULL - кнопка подключена к VCC, пин подтянут к GND, pinMode - INPUT
													// NORM_OPEN - кнопка по умолчанию разомкнута
													// NORM_CLOSE - кнопка по умолчанию замкнута
	
void setDebounce(uint16_t debounce);				// установка времени антидребезга (по умолчанию 80 мс)
void setTimeout(uint16_t timeout);					// установка таймаута удержания (по умолчанию 500 мс)	
void setStepTimeout(uint16_t step_timeout);			// установка таймаута между инкрементами (по умолчанию 400 мс)	
void setType(boolean type);							// установка типа кнопки (HIGH_PULL - подтянута к питанию, LOW_PULL - к gnd)	
void setDirection(boolean dir);						// установка направления (разомкнута/замкнута по умолчанию - NORM_OPEN, NORM_CLOSE)	
	
void setTickMode(boolean tickMode);					// (MANUAL / AUTO) ручной или автоматический опрос кнопки функцией tick()	
													// MANUAL - нужно вызывать функцию tick() вручную														
													// AUTO - tick() входит во все остальные функции и опрашивается сама
	
void tick();										// опрос кнопки	
void tick(boolean state);							// опрос внешнего значения (0 нажато, 1 не нажато) (для матричных, резистивных клавиатур и джойстиков)
	
boolean isPress();      // возвращает true при нажатии на кнопку. Сбрасывается после вызова
boolean isRelease();    // возвращает true при отпускании кнопки. Сбрасывается после вызова
boolean isClick();      // возвращает true при клике. Сбрасывается после вызова
boolean isHolded();     // возвращает true при удержании дольше timeout. Сбрасывается после вызова
boolean isHold();       // возвращает true при нажатой кнопке, не сбрасывается
boolean state();        // возвращает состояние кнопки

boolean isSingle();     // возвращает true при одиночном клике. Сбрасывается после вызова
boolean isDouble();     // возвращает true при двойном клике. Сбрасывается после вызова
boolean isTriple();     // возвращает true при тройном клике. Сбрасывается после вызова
	
boolean hasClicks();    // проверка на наличие кликов. Сбрасывается после вызова
uint8_t getClicks();    // вернуть количество кликов
	
boolean isStep();       // возвращает true по таймеру setStepTimeout, смотри пример
```
</p>
</details>

---

### GyverEncoder v2.4
Библиотека для отработки энкодера с Arduino. Возможности:
- Отработка поворота с антидребезгом
- Отработка нажатия кнопки с антидребезгом
- Отработка нажатия и удержания кнопки
- Отработка "нажатого поворота"
- Работа с двумя типами экнодеров

### GyverFilters v1.3
Библиотека с некоторыми удобными фильтрами для Arduino:
- GFilterRA - компактная альтернатива фильтра экспоненциальное бегущее среднее (Running Average)			
- GMedian3 - быстрый медианный фильтр 3-го порядка (отсекает выбросы)
- GMedian - медианный фильтр N-го порядка. Порядок настраивается в GyverFilters.h - MEDIAN_FILTER_SIZE
- GABfilter - альфа-бета фильтр (разновидность Калмана для одномерного случая)
- GKalman - упрощённый Калман для одномерного случая (на мой взгляд лучший из фильтров)

### GyverTimer v1.0
Компактная альтернатива конструкции таймера с millis() / micros(), обеспечивающая удобную мультизадачность на Arduino
- Вся работа с таймером заменяется одной функцией
- Миллисекундный и микросекундный таймер
- Автоматический и ручной режим работы

### GyverHacks v2.0
Библиотека с некоторыми удобными хаками для Arduino UNO/NANO/MINI (atmega328):
- Быстрые аналоги стандартных функций чтения/записи
- Изменение частоты ШИМ пинов (3, 5, 6, 9, 10, 11)
- Установка ШИМ на пинах 9 и 10 в режим 10 бит (abalogWrite 0-1023)
- Генерация ШИМ на ЛЮБОМ пине (частота ~150 Гц)
- Измерение напряжения питания + калибровка константы
- Перевод напряжения питания в проценты по графику разряда для разных типов АКБ
- Измерение температуры ядра

### GyverMotor v1.0
Библиотека для удобного управления моторчиками через драйвер полного моста для Arduino
- Контроль скорости и направления вращения
- Встроенный инструмент для настройки частоты ШИМ
- Работа с 10 битным ШИМом

### GyverRGB v1.5
Библиотека для удобного управления RGB светодиодами и лентами для Arduino
- Работа в пространстве RGB
- Работа в пространстве HSV
- Установка цвета в формате HEX
- 16 предустановленных цветов
- Настройка полярности ШИМ	
- Функция плавной смены цвета
- Возможность управления 6-ю RGB диодами/лентами с одной Arduino (встроенный генератор ШИМ на ВСЕХ 20 пинах atmega328)

### GyverRTOS v1.0
Система реального времени для Arduino: максимальное энергосбережение и мультизадачность
- Во время сна функция millis() не работает, вместо неё используется переменная mainTimer, которая автоматически увеличивается при каждом пробуждении на время сна (SLEEP_PERIOD) В ХОЛОСТОМ РЕЖИМЕ
- Выполнение функций занимает время, поэтому ЕСЛИ ВЫПОЛНЯЕТСЯ ЗАДАЧА, время выполнения тоже автоматически суммируется в mainTimer
- МЫ создаём несколько функций с разным периодом выполнения (задачи)
- Настраиваем период пробуждения системы (минимально 15 мс)
Далее всё автоматически:
- Рассчитывается время до выполнения самой "ближней" задачи
- Система периодически просыпается и считает таймеры
- При наступлении времени выполнения ближайшей задачи, она выполняется.
После этого снова выполняется расчёт времени до новой ближайшей задачи  
Как итог: Ардуино спит (в зависимости от периодов) 99.999% времени, просыпаясь только для проверки флага и расчёта таймера

### TM74HC595_Gyver v1.1
Библиотека для дисплея на сдвиговике TM74HC595 с Arduino
- Подробное описание здесь http://alexgyver.ru/tm74hc595_display/

### TM1637_Gyver v1.1
Библиотека для дисплея на сдвиговике TM1637 с Arduino
- Подробное описание здесь http://alexgyver.ru/tm1637_display/